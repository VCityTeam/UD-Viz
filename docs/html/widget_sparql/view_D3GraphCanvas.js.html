<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link type="text/css" rel="stylesheet" href="custom.css"><title>Source: view/D3GraphCanvas.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">@ud-viz/widget_sparql</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="D3GraphCanvas_D3GraphCanvas.html">D3GraphCanvas</a></div><div class="sidebar-section-children"><a href="Graph.html">Graph</a></div><div class="sidebar-section-children"><a href="SparqlEndpointResponseProvider.html">SparqlEndpointResponseProvider</a></div><div class="sidebar-section-children"><a href="SparqlQuery.html">SparqlQuery</a></div><div class="sidebar-section-children"><a href="SparqlQueryWindow.html">SparqlQueryWindow</a></div><div class="sidebar-section-children"><a href="Table.html">Table</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-tutorials"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-Changelog.html">Changelog</a></div><div class="sidebar-section-children"><a href="tutorial-Contributing.html">Contributing</a></div><div class="sidebar-section-children"><a href="tutorial-Contributors.html">Contributors</a></div><div class="sidebar-section-children"><a href="tutorial-Definitions.html">Definitions</a></div><div class="sidebar-section-children"><a href="tutorial-Developers.html">Developers</a></div><div class="sidebar-section-children"><a href="tutorial-ReleasePublish.html">ReleasePublish</a></div><div class="sidebar-section-children"><a href="tutorial-Reproducibility.html">Reproducibility</a></div><div class="sidebar-section-children"><a href="tutorial-architecture.html">architecture</a></div><div class="sidebar-section-children"><a href="tutorial-game.html">game</a></div><div class="sidebar-section-children"><a href="tutorial-how_to_import.html">how_to_import</a></div><div class="sidebar-section-children"><a href="tutorial-initial_camera_transform.html">initial_camera_transform</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#OptionsRenderJSON">OptionsRenderJSON</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="navbar-item"><a id="Github" href="https://github.com/VCityTeam/UD-Viz" target="_blank">Github</a></div><div class="navbar-item"><a id="Examples" href="https://ud-viz.vcityliris.data.alpha.grandlyon.com/" target="_blank">Examples</a></div><div class="navbar-item"><a id="udvizHome" href="../" target="">udviz</a></div><div class="navbar-item"><a id="udviz/extensions_3d_tiles_temporal" href="../extensions_3d_tiles_temporal" target="">udviz/extensions_3d_tiles_temporal</a></div><div class="navbar-item"><a id="udviz/frame3d" href="../frame3d" target="">udviz/frame3d</a></div><div class="navbar-item"><a id="udviz/game_browser" href="../game_browser" target="">udviz/game_browser</a></div><div class="navbar-item"><a id="udviz/game_browser_template" href="../game_browser_template" target="">udviz/game_browser_template</a></div><div class="navbar-item"><a id="udviz/game_editor" href="../game_editor" target="">udviz/game_editor</a></div><div class="navbar-item"><a id="udviz/game_node" href="../game_node" target="">udviz/game_node</a></div><div class="navbar-item"><a id="udviz/game_node_template" href="../game_node_template" target="">udviz/game_node_template</a></div><div class="navbar-item"><a id="udviz/game_shared" href="../game_shared" target="">udviz/game_shared</a></div><div class="navbar-item"><a id="udviz/game_shared_template" href="../game_shared_template" target="">udviz/game_shared_template</a></div><div class="navbar-item"><a id="udviz/show_room" href="../show_room" target="">udviz/show_room</a></div><div class="navbar-item"><a id="udviz/smdb" href="../smdb" target="">udviz/smdb</a></div><div class="navbar-item"><a id="udviz/utils_browser" href="../utils_browser" target="">udviz/utils_browser</a></div><div class="navbar-item"><a id="udviz/utils_node" href="../utils_node" target="">udviz/utils_node</a></div><div class="navbar-item"><a id="udviz/utils_shared" href="../utils_shared" target="">udviz/utils_shared</a></div><div class="navbar-item"><a id="udviz/visualizer" href="../visualizer" target="">udviz/visualizer</a></div><div class="navbar-item"><a id="udviz/widget_3d_tiles" href="../widget_3d_tiles" target="">udviz/widget_3d_tiles</a></div><div class="navbar-item"><a id="udviz/widget_base_map" href="../widget_base_map" target="">udviz/widget_base_map</a></div><div class="navbar-item"><a id="udviz/widget_bookmark" href="../widget_bookmark" target="">udviz/widget_bookmark</a></div><div class="navbar-item"><a id="udviz/widget_camera_positioner" href="../widget_camera_positioner" target="">udviz/widget_camera_positioner</a></div><div class="navbar-item"><a id="udviz/widget_extensions_3d_tiles_temporal" href="../widget_extensions_3d_tiles_temporal" target="">udviz/widget_extensions_3d_tiles_temporal</a></div><div class="navbar-item"><a id="udviz/widget_geocoding" href="../widget_geocoding" target="">udviz/widget_geocoding</a></div><div class="navbar-item"><a id="udviz/widget_guided_tour" href="../widget_guided_tour" target="">udviz/widget_guided_tour</a></div><div class="navbar-item"><a id="udviz/widget_layer_choice" href="../widget_layer_choice" target="">udviz/widget_layer_choice</a></div><div class="navbar-item"><a id="udviz/widget_legonizer" href="../widget_legonizer" target="">udviz/widget_legonizer</a></div><div class="navbar-item"><a id="udviz/widget_planar_controls" href="../widget_planar_controls" target="">udviz/widget_planar_controls</a></div><div class="navbar-item"><a id="udviz/widget_slide_show" href="../widget_slide_show" target="">udviz/widget_slide_show</a></div><div class="navbar-item"><a id="udviz/widget_sparql" href="../widget_sparql" target="">udviz/widget_sparql</a></div><div class="navbar-item"><a id="udviz/widget_versioning" href="../widget_versioning" target="">udviz/widget_versioning</a></div><div class="navbar-item"><a id="udviz/widget_workspace" href="../widget_workspace" target="">udviz/widget_workspace</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">view_D3GraphCanvas.js</h1></header><article><pre class="prettyprint source lang-js"><code>import { Graph } from '../model/Graph';

import * as d3 from 'd3';
import { getUriLocalname, tokenizeURI } from '@ud-viz/utils_browser';
import * as THREE from 'three';

export class D3GraphCanvas extends THREE.EventDispatcher {
  /**
   * Create a new D3 graph from a JSON object.
   * Adapted from https://observablehq.com/@d3/force-directed-graph#chart and
   * https://www.d3indepth.com/zoom-and-pan/
   *
   * @param {object} config The sparqlModule configuration.
   * @param {number} config.height The SVG canvas height.
   * @param {number} config.width The SVG canvas width.
   * @param {number} config.fontSize The font size to use for node and link labels.
   * @param {object} config.namespaceLabels Prefix declarations which will replace text labels in the Legend. This doesn't (yet) affect the legend font size.
   * @param {Function} handleZoom The function that handles the zoom.
   * @param {Function} formatResponse The function that formats the response from JSON into a list of nodes and links.
   */
  constructor(config, handleZoom, formatResponse) {
    super();
    this.id = THREE.MathUtils.generateUUID();
    this.height = config.height || 800;
    this.width = config.width || 1500;
    this.fontSize = config.fontSize || 4;
    this.fontFamily = config.fontFamily || 'Arial';
    this.strokeWidth = config.strokeWidth || 0.75;
    this.nodeSize = config.nodeSize || 7;
    this.defaultColor = config.defaultColor || 'white';
    this.linkColor = config.linkColor || '#999';
    this.nodeStrokeColor = config.nodeStrokeColor || 'black';
    this.fontSizeLegend = config.fontSizeLegend || 15;

    this.knownNamespaceLabels = config.namespaceLabels;
    this.svg = d3 // the svg in which the graph is displayed
      .create('svg')
      .attr('class', 'd3_graph')
      .attr('id', this.id)
      .attr('viewBox', [0, 0, this.width, this.height])
      .style('display', 'hidden');
    this.data = new Graph();

    this.tooltip = d3
      .create('div')
      .style('visibility', 'hidden')
      .attr('class', 'tooltip')
      .style('background-color', 'white')
      .style('border', 'solid')
      .style('border-width', '2px')
      .style('border-radius', '5px')
      .style('position', 'absolute')
      .style('padding', '5px');

    if (handleZoom == undefined) {
      this.handleZoom = (ev) => {
        d3.selectAll('g.graph')
          .attr('height', '100%')
          .attr('width', '100%')
          .attr(
            'transform',
            'translate(' +
              ev.transform.x +
              ',' +
              ev.transform.y +
              ') scale(' +
              ev.transform.k +
              ')'
          );
      };
    } else {
      this.handleZoom = handleZoom;
    }

    if (formatResponse == undefined) {
      this.formatResponse = (response, graph) => {
        /* If the query is formatted using subject, predicate, object, and optionally
            subjectType and objectType variables the node color based on the type of the
            subject or object's respective type */
        if (
          !response.head.vars.includes('subject') ||
          !response.head.vars.includes('predicate') ||
          !response.head.vars.includes('object')
        ) {
          throw (
            'Missing endpoint response bindings for graph construction. Needs at least "subject", "predicate", "object". Found binding: ' +
            response.head.vars
          );
        }
        const getNodeColorId = (type) => {
          const colorScale = d3
            .scaleOrdinal()
            .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
            .range(d3.schemeCategory10); // d3.schemeCategory10 returns an array of 10 colors and d3.scaleOrdinal is used to create an ordinal scale
          if (!this.data.typeList.includes(type)) {
            this.data.typeList.push(type);
            this.data.legend.push({
              type: type,
              color: colorScale(this.data.typeList.findIndex((d) => d == type)),
            });
          }
          return colorScale(this.data.typeList.findIndex((d) => d == type));
        };
        for (const triple of response.results.bindings) {
          if (
            // if the subject doesn't exist yet
            graph.nodes.find((n) => n.id == triple.subject.value) == undefined
          ) {
            const node = { id: triple.subject.value };
            if (
              // if there is a subjectType assign a type and color id
              triple.subjectType
            ) {
              node.type = getUriLocalname(triple.subjectType.value);
              node.color_id = getNodeColorId(node.type);
            }
            graph.nodes.push(node);
          }
          if (
            // if the object doesn't exist yet
            graph.nodes.find((n) => n.id == triple.object.value) == undefined
          ) {
            const node = { id: triple.object.value };
            if (
              // if there is an objectType assign a color id
              triple.objectType
            ) {
              node.type = getUriLocalname(triple.objectType.value);
              node.color_id = getNodeColorId(node.type);
            }
            graph.nodes.push(node);
          }
          const link = {
            source: triple.subject.value,
            target: triple.object.value,
            label: triple.predicate.value,
          };
          graph.links.push(link);
        }
      };
    } else {
      this.formatResponse = formatResponse;
    }
  }

  // / Data Functions ///

  /**
   * Generate the label of a clustered node
   *
   * @param {object} node a node
   * @param {D3GraphCanvas} graph this
   * @returns {string} the desired label of the node
   */
  generateClusterLabel(node, graph) {
    const map = new Map();
    if (graph.possessCycle(node.id, map))
      return (
        getUriLocalname(node.id) + ' [' + node.child.length.toString() + ']'
      );
    return (
      getUriLocalname(node.id) +
      ' [' +
      graph.generateDescendantList(node.id, []).length.toString() +
      ']'
    );
  }

  /**
   * Retrieve the ID of all the node's descendants
   *
   * @param {string} node_id a node ID
   * @param {Array} list an empty list
   * @returns {Array} the list of all the node's descendants
   */
  generateDescendantList(node_id, list) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((element) => {
      return element.id == node_id;
    });
    if (node != undefined &amp;&amp; node.child) {
      for (const child_id of node.child) {
        if (
          list.find((element) => {
            return element == child_id;
          }) == undefined
        ) {
          list.push(child_id);
          this.generateDescendantList(child_id, list);
        }
      }
    }
    return list;
  }

  /**
   * Return true if the graph possesses a cycle, false otherwise
   *
   * @param {string} node_id a node ID
   * @param {Map} map an empty map at first
   * @returns {boolean} the result
   */
  possessCycle(node_id, map) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    if (map.size &lt; allNodes.length) {
      for (const node of allNodes) {
        map.set(node.id, 'white');
      }
    }
    const node = allNodes.find((element) => {
      return element.id == node_id;
    });
    if (node != undefined) {
      map.set(node.id, 'grey');
      if (node.child != undefined) {
        for (const child_id of node.child) {
          if (map.get(child_id) == 'grey') {
            return true;
          } else if (map.get(child_id) == 'white') {
            if (this.possessCycle(child_id, map)) {
              return true;
            }
          }
        }
      }
      map.set(node.id, 'black');
      return false;
    }
    console.log('[haveCycle] node undefined');
    return undefined;
  }

  /**
   * Create and initialize the 'child' and 'parent' properties for all nodes
   *
   */
  addChildParent() {
    for (const link of this.data.links) {
      const source = this.data.nodes.find((element) => {
        return element.id == link.source;
      });
      const target = this.data.nodes.find((element) => {
        return element.id == link.target;
      });

      if (target != undefined &amp;&amp; source != undefined) {
        if (!('parent' in target)) {
          target.parent = [];
        }
        if (!('child' in source)) {
          source.child = [];
        }
        if (
          target.parent.find((element) => {
            return element == source.id;
          }) == undefined
        ) {
          target.parent.push(source.id);
        }
        if (
          source.child.find((element) => {
            return element == target.id;
          }) == undefined
        ) {
          source.child.push(target.id);
        }
      }
    }

    let cyclic = false;

    for (const node of this.data.nodes) {
      const map = new Map();
      if (this.possessCycle(node.id, map)) {
        cyclic = true;
      }
    }

    if (!cyclic) {
      for (const node of this.data.nodes) {
        if (!('parent' in node)) {
          node.group = 0;
        }
      }

      let modif = true;
      let i = 0;

      while (modif) {
        modif = false;
        for (const node of this.data.nodes) {
          if (node.group == i) {
            if (node.child != undefined) {
              for (const childNodeId of node.child) {
                const childNode = this.data.nodes.find((element) => {
                  return element.id == childNodeId;
                });
                childNode.group = i + 1;
                modif = true;
              }
            }
          }
        }
        i++;
      }
    } else {
      for (const node of this.data.nodes) {
        node.group = 0;
      }
    }
  }

  /**
   * Return true if any parent of the node is a cluster, false otherwise
   *
   * @param {string} node_id a node ID
   * @returns {boolean} the result
   */
  OneParentCluster(node_id) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((element) => {
      return element.id == node_id;
    });
    if (node.parent != undefined) {
      for (const parent_id of node.parent) {
        const parent = allNodes.find((element) => {
          return element.id == parent_id;
        });
        if (parent != undefined) {
          if (parent.cluster) {
            return true;
          }
        }
      }
    }
    return false;
  }

  /**
   * Return true if any parent of the node is visible, false otherwise
   *
   * @param {string} node_id a node ID
   * @returns {boolean} the result
   */
  OneParentVisible(node_id) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((element) => {
      return element.id == node_id;
    });
    if (node != undefined) {
      if (node.parent != undefined) {
        for (const parent_id of node.parent) {
          const parent = this.data.nodes.find(
            (element) => element.id == parent_id
          );
          if (parent != undefined) {
            return true;
          }
        }
      }
    } else {
      console.debug('[OneParentVisible] node undefined: ', node_id);
    }
    return false;
  }

  /**
   * Change the state of the node from simple node to cluster, or the opposite
   *
   * @param {string} node_id a node ID
   */
  changeVisibilityDescendants(node_id) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((d) => d.id == node_id);
    if (node != undefined) {
      if (node.child != undefined) {
        node.cluster = node.cluster != true;
        const descendants = [];
        this.generateDescendantList(node_id, descendants);
        if (node.cluster) {
          for (const descendant_id of descendants) {
            this.hideNode(descendant_id);
          }
          for (const descendant_id of descendants) {
            const nodeLinks = [];
            this.data.links.forEach((element) => {
              if (
                element.source.id == descendant_id ||
                element.target.id == descendant_id
              ) {
                nodeLinks.push(element);
              }
            });
            for (const link of nodeLinks) {
              this.hideLink(link);
            }
          }
          let link;
          this.data._links.forEach((element) => {
            if (
              node.child.includes(element.source) &amp;&amp;
              element.source != node.id
            ) {
              link = this.createNewLink(
                node_id,
                element.target,
                node_id + '_children_cluster'
              );
              if (link) link.realLink = false;
            }
            if (
              node.child.includes(element.target) &amp;&amp;
              element.target != node.id
            ) {
              link = this.createNewLink(
                element.source,
                node_id,
                node_id + '_children_cluster'
              );
              if (link) link.realLink = false;
            }
          });
        } else {
          for (const descendant_id of descendants) {
            if (
              this.OneParentVisible(descendant_id) &amp;&amp;
              !this.OneParentCluster(descendant_id)
            ) {
              this.showNode(descendant_id);
            }
          }
          for (const descendant_id of descendants) {
            if (
              this.OneParentVisible(descendant_id) &amp;&amp;
              !this.OneParentCluster(descendant_id)
            ) {
              const nodeLinks = [];
              this.data._links.forEach((element) => {
                if (
                  (element.source == descendant_id ||
                    element.target == descendant_id) &amp;&amp;
                  this.data.nodes.find((d) => d.id == element.source) !=
                    undefined &amp;&amp;
                  this.data.nodes.find((d) => d.id == element.target) !=
                    undefined
                ) {
                  nodeLinks.push(element);
                }
              });
              for (const link of nodeLinks) {
                this.showLink(link);
              }
            }
          }
          this.data.links.forEach((element) => {
            if (element.label == node_id + '_children_cluster') {
              this.removeLink(element);
            }
          });
        }
      }
      this.setLinkIndexAndNum();
    } else {
      console.debug('[changeVisibilityDescendant] node undefined: ', node_id);
    }
  }

  /**
   * Change the state of the node from simple node to cluster, or the opposite
   *
   * @param {string} node_id a node ID
   */
  changeVisibilityChildren(node_id) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((d) => d.id == node_id);
    if (node != undefined) {
      if (node.child != undefined) {
        node.cluster = node.cluster != true;
        if (node.cluster) {
          for (const child_id of node.child) {
            this.hideNode(child_id);
          }
          for (const child_id of node.child) {
            const nodeLinks = [];
            this.data.links.forEach((element) => {
              if (
                element.source.id == child_id ||
                element.target.id == child_id
              ) {
                nodeLinks.push(element);
              }
            });
            for (const link of nodeLinks) {
              this.hideLink(link);
            }
          }
          let link;
          this.data._links.forEach((element) => {
            if (
              node.child.includes(element.source) &amp;&amp;
              element.source != node.id
            ) {
              link = this.createNewLink(
                node_id,
                element.target,
                node_id + '_children_cluster'
              );
              if (link) link.realLink = false;
            }
            if (
              node.child.includes(element.target) &amp;&amp;
              element.target != node.id
            ) {
              link = this.createNewLink(
                element.source,
                node_id,
                node_id + '_children_cluster'
              );
              if (link) link.realLink = false;
            }
          });
        } else {
          for (const child_id of node.child) {
            if (
              this.OneParentVisible(child_id) &amp;&amp;
              !this.OneParentCluster(child_id)
            ) {
              this.showNode(child_id);
            }
          }
          for (const child_id of node.child) {
            if (
              this.OneParentVisible(child_id) &amp;&amp;
              !this.OneParentCluster(child_id)
            ) {
              const nodeLinks = [];
              this.data._links.forEach((element) => {
                if (
                  (element.source == child_id || element.target == child_id) &amp;&amp;
                  this.data.nodes.find((d) => d.id == element.source) !=
                    undefined &amp;&amp;
                  this.data.nodes.find((d) => d.id == element.target) !=
                    undefined
                ) {
                  nodeLinks.push(element);
                }
              });
              for (const link of nodeLinks) {
                this.showLink(link);
              }
            }
          }
          this.data.links.forEach((element) => {
            if (element.label == node_id + '_children_cluster') {
              this.removeLink(element);
            }
          });
        }
      }
      this.setLinkIndexAndNum();
    } else {
      console.debug('[changeVisibilityChildren] node undefined: ', node_id);
    }
  }

  /**
   * Create a new link and add it to the graph
   *
   * @param {string} source source of the link
   * @param {string} target target of the link
   * @param {string} label label of the link
   * @returns {object} the created link
   */
  createNewLink(source, target, label) {
    if (
      source != target &amp;&amp;
      this.data.nodes.find((element) => element.id == source) != undefined &amp;&amp;
      this.data.nodes.find((element) => element.id == target) != undefined
    ) {
      const link = {};
      link.source = source;
      link.target = target;
      link.label = label;
      this.data.links.push(link);
      this.setLinkIndexAndNum();
      return link;
    }
    return null;
  }

  /**
   * Create a new node and add it to the graph
   *
   * @param {string} node_id a node ID
   * @returns {object} the created node
   */
  createNewNode(node_id) {
    const node = {};
    node.id = node_id;
    node.cluster = false;
    node.display = true;
    this.data.nodes.push(node);
    return node;
  }

  /**
   * Remove the node from the graph
   *
   * @param {string} node_id a node ID
   */
  removeNode(node_id) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = this.data.nodes.find((element) => {
      return element.id == node_id;
    });
    if (node != undefined) {
      this.data.nodes = this.data.nodes.filter((d) => d.id != node.id);
      for (const child_id of node.child) {
        const child = allNodes.find((element) => {
          return element.id == child_id;
        });
        child.parent = child.parent.filter((d) => d != node.id);
      }
      this.data.links = this.data.links.filter(
        (d) => d.source.id != node_id &amp;&amp; d.target.id != node_id
      );
      this.data._links = this.data._links.filter(
        (d) => d.source != node_id &amp;&amp; d.target != node_id
      );
      this.update();
    } else {
      console.debug('[removeNode] node undefined: ', node_id);
    }
  }

  /**
   * Remove the link from the graph
   *
   * @param {object} link the link
   */
  removeLink(link) {
    this.data.links = this.data.links.filter((d) => d != link);
    this.data._links = this.data._links.filter((d) => d != link);
    this.setLinkIndexAndNum();
  }

  /**
   * Create a new cluster and add it to the graph
   *
   * @param {string} cluster_id the ID of the created cluster
   * @param {Array} nodes_id an array of node IDs
   * @param {string} source_id the ID of the node to which the created cluster will be linked
   * @returns {object} the created cluster
   */
  createNewCluster(cluster_id, nodes_id, source_id = undefined) {
    const cluster = this.createNewNode(cluster_id);
    cluster.cluster = false;
    cluster.child = nodes_id;
    cluster.realNode = false;
    const allNodes = this.data.nodes.concat(this.data._nodes);
    for (const node_id of nodes_id) {
      const node = allNodes.find((element) => {
        return element.id == node_id;
      });
      if (!('parent' in node)) {
        node.parent = [cluster_id];
      } else {
        node.parent.push(cluster_id);
      }
    }
    if (source_id != undefined) {
      this.createNewLink(source_id, cluster_id, 'isCluster');
      const source = this.data.nodes.find((element) => {
        return element.id == source_id;
      });
      source.child.push(cluster_id);
      cluster.parent = [source_id];
    }
    this.changeVisibilityChildren(cluster_id);
    return cluster;
  }

  /**
   * Hide the node from the graph
   *
   * @param {string} node_id a node ID
   */
  hideNode(node_id) {
    const node = this.data.nodes.find((element) => {
      return element.id == node_id;
    });
    if (node != undefined) {
      const node_copy = { ...node };
      this.data.nodes = this.data.nodes.filter((element) => {
        return element.id != node_id;
      });
      const propertiesToDelete = ['index', 'vx', 'vy', 'x', 'y'];
      propertiesToDelete.forEach((prop) => delete node_copy[prop]);
      this.data._nodes.push(node_copy);
    } else {
      console.debug('[hideNode] node undefined: ', node_id);
    }
  }

  /**
   * Show the hidden node
   *
   * @param {string} node_id a node ID
   */
  showNode(node_id) {
    const node = this.data._nodes.find((element) => {
      return element.id == node_id;
    });
    if (node != undefined) {
      const node_copy = { ...node };
      this.data._nodes = this.data._nodes.filter((element) => {
        return element.id != node_id;
      });
      this.data.nodes.push(node_copy);
    } else {
      console.debug('[showNode] node undefined: ', node_id);
    }
  }

  /**
   * Hide the link from the graph
   *
   * @param {object} link a link
   */
  hideLink(link) {
    if (link != undefined) {
      const link_copy = { ...link };
      this.data.links = this.data.links.filter((element) => {
        return element != link;
      });
      delete link_copy['index'];
      link_copy.source = link_copy.source.id;
      link_copy.target = link_copy.target.id;
      this.data._links.push(link_copy);
    } else {
      console.debug('[hideLink] link undefined: ', link);
    }
  }

  /**
   * Show the hidden link of the graph
   *
   * @param {object} link a link
   */
  showLink(link) {
    if (link != undefined) {
      const link_copy = { ...link };
      this.data._links = this.data._links.filter((element) => {
        return element != link;
      });
      this.data.links.push(link_copy);
    } else {
      console.debug('[showLink] link undefined: ', link);
    }
  }

  /**
   * Return a list of the node's children types
   *
   * @param {string} node_id a node ID
   * @returns {Array} the list
   */
  getChildrenType(node_id) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((element) => {
      return element.id == node_id;
    });
    const childrenType = [];
    if (node != undefined) {
      for (const child_id of node.child) {
        const child = this.data.nodes.find((element) => {
          return element.id == child_id;
        });
        if (
          child != undefined &amp;&amp;
          child.type != undefined &amp;&amp;
          childrenType.find((element) => {
            return element == child.type;
          }) == undefined
        ) {
          childrenType.push(child.type);
        }
      }
    }
    return childrenType;
  }

  /**
   * Return a list of the different types of nodes
   *
   * @returns {Array} the list
   */
  getTypeList() {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const typeList = [];
    for (const node of allNodes) {
      if (
        node != undefined &amp;&amp;
        node.type != undefined &amp;&amp;
        typeList.find((element) => {
          return element == node.type;
        }) == undefined
      ) {
        typeList.push(node.type);
      }
    }
    return typeList;
  }

  /**
   * Returns the list of children of the node of this type
   *
   * @param {string} node_id a node ID
   * @param {string} type a type
   * @returns {Array} the list
   */
  getChildrenByType(node_id, type) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const node = allNodes.find((element) => {
      return element.id == node_id;
    });
    const children = [];
    if (node != undefined) {
      for (const child_id of node.child) {
        const child = allNodes.find((element) => {
          return element.id == child_id;
        });
        if (child != undefined &amp;&amp; child.type == type) {
          children.push(child_id);
        }
      }
    }
    return children;
  }

  /**
   * Return a list of node IDs whose group is equal to groupIndex
   *
   * @param {number} groupIndex the index of the group
   * @returns {Array} the list
   */
  getNodeByGroup(groupIndex) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const nodes = [];
    for (const node of allNodes) {
      if (node.group == groupIndex) {
        nodes.push(node.id);
      }
    }
    return nodes;
  }

  /**
   * Return a list of node IDs whose type is equal to typeName
   *
   * @param {string} typeName the name of the type
   * @returns {Array} the list
   */
  getNodeByType(typeName) {
    const allNodes = this.data.nodes.concat(this.data._nodes);
    const nodes = [];
    for (const node of allNodes) {
      if (node.type == typeName) {
        nodes.push(node.id);
      }
    }
    return nodes;
  }

  /**
   * Set the link index and the number of links between two nodes
   *
   */
  setLinkIndexAndNum() {
    this.linkNum = {};
    for (const link of this.data.links) {
      const source = link.source.id || link.source;
      const target = link.target.id || link.target;
      if (this.linkNum[source + ',' + target] == undefined) {
        this.linkNum[source + ',' + target] = 1;
      } else {
        this.linkNum[source + ',' + target] =
          this.linkNum[source + ',' + target] + 1;
      }
      link.linkindex = this.linkNum[source + ',' + target];
    }
  }

  /**
   * Initialize the d3 SVG canvas based on the data from a graph dataset
   *
   * @param {object} response an RDF JSON object ideally formatted by this.formatResponseData().
   */
  init(response) {
    this.formatResponse(response, this.data);
    this.setLinkIndexAndNum();

    this.addChildParent();
    for (const node of this.data.nodes) {
      node.cluster = false;
      node.realNode = true;
      node.display = true;
    }

    for (const link of this.data.links) {
      link.realLink = true;
    }

    this.g = this.svg.append('g').attr('class', 'graph');
    this.link = this.g.append('g').selectAll('.link');
    this.nodeCircle = this.g.append('g').selectAll('.node');
    this.nodeCluster = this.g.append('g').selectAll('.node');
    this.label = this.svg.append('g').attr('class', 'graph');

    this.distanceLink = 30;
    this.chargeStrength = -40;
    this.forceCenter = 0.1;

    this.simulation = d3
      .forceSimulation(this.data.nodes) // defines simulation nodes
      .force(
        'link',
        d3
          .forceLink(this.data.links)
          .id((d) => d.id) // tells d3 how to identify nodes
          .distance(this.distanceLink)
      )
      .force('charge', d3.forceManyBody().strength(this.chargeStrength)) // adds a repulsive force between the nodes
      .force('x', d3.forceX(this.width / 2).strength(this.forceCenter))
      .force('y', d3.forceY(this.height / 2).strength(this.forceCenter))
      .force('collide', d3.forceCollide(5))
      .alphaTarget(1)
      .on('tick', () => this.ticked(this));

    // adds an event handler for zoom management
    const zoom = d3.zoom().on('zoom', (event) => {
      if (this.handleZoom.length == 1) {
        this.handleZoom(event);
      } else {
        this.handleZoom(event, this);
      }
    });

    this.svg.call(zoom);

    this.node_label_cluster = this.label.selectAll('.node_label_cluster');
    this.node_label = this.label.selectAll('.node_label');
    this.link_label = this.label.selectAll('.link_label');

    // create legend
    if (this.data.legend.length > 0) {
      this.svg
        .append('text')
        .attr('x', 12)
        .attr('y', 24)
        .style('font-size', this.fontSizeLegend)
        .style('text-decoration', 'underline')
        .text('Legend');

      // legend colors
      this.svg
        .append('g')
        .attr('stroke', '#111')
        .attr('stroke-width', 1)
        .selectAll('rect')
        .data(this.data.legend)
        .join('rect')
        .attr('x', 12)
        .attr('y', (d, i) => 32 + i * 16)
        .attr('width', 10)
        .attr('height', 10)
        .style('fill', (d) => d.color)
        .append('title')
        .text((d) => d);

      // legend text
      this.svg
        .append('g')
        .selectAll('text')
        .data(this.data.legend)
        .join('text')
        .attr('x', 26)
        .attr('y', (d, i) => 41 + i * 16)
        .text((d) => d.type)
        .style('font-size', this.fontSizeLegend);
    }

    this.svg
      .append('defs')
      .append('marker')
      .attr('id', 'arrowhead')
      .attr('viewBox', '-0 -5 10 10')
      .attr('orient', 'auto')
      .attr('markerWidth', (this.strokeWidth / 0.75) * 4)
      .attr('markerHeight', 10)
      .attr('refX', 5)
      .attr('xoverflow', 'visible')
      .append('svg:path')
      .attr('d', 'M 0 0 L 0,5 L 10,0 L 0,-5')
      .attr('fill', this.linkColor)
      .style('stroke', 'none');

    this.update();
    this.dispatchEvent({
      type: 'graph_initialized',
      message: 'd3Graph init finished',
      event: null,
      graphId: this.id,
    });
  }

  /**
   * Update the forces of the simulation
   *
   */
  updateForceSimulation() {
    this.simulation.force('link').distance(this.distanceLink);
    this.simulation.force('charge').strength(this.chargeStrength);
    this.simulation.force('x').strength(this.forceCenter);
    this.simulation.force('y').strength(this.forceCenter);
    this.simulation.alpha(1).restart();
  }

  /**
   * Clear and update the d3 SVG canvas based on the data from a graph dataset. Also apply event dispatchers
   *
   *
   */
  update() {
    const hexToDec = function (hex) {
      const code = hex.charCodeAt(0);
      if (code >= 97) return code - 87;
      return parseInt(hex);
    };

    const htmlTooltip = function (data, propertiesOff = []) {
      let str = '';
      for (const property in data) {
        if (!propertiesOff.includes(property))
          if (property != 'source' &amp;&amp; property != 'target')
            str = str + `&lt;strong>${property}:&lt;/strong> ${data[property]}&lt;br>`;
          else
            str =
              str + `&lt;strong>${property}:&lt;/strong> ${data[property]['id']}&lt;br>`;
      }
      return str;
    };

    const modifyColorTint = function (hex, k) {
      hex = hex.toLowerCase();
      let r = (hexToDec(hex[1]) * 16 + hexToDec(hex[2])) * k;
      if (r > 255) r = 255;
      let g = (hexToDec(hex[3]) * 16 + hexToDec(hex[4])) * k;
      if (g > 255) g = 255;
      let b = (hexToDec(hex[5]) * 16 + hexToDec(hex[6])) * k;
      if (b > 255) b = 255;
      const res =
        'rgb(' + r.toString() + ',' + g.toString() + ',' + b.toString() + ')';
      return res;
    };

    const nodeCircleSize = function (d, graph) {
      if (d.group != undefined) return graph.nodeSize - d.group;
      return graph.nodeSize;
    };

    const nodeCircleColor = function (d, graph) {
      if (d.color_id) return d.color_id;
      return graph.defaultColor;
    };

    // attach the data to svg elements
    this.nodeCircle = this.nodeCircle.data(
      this.data.nodes.filter((d) => !d.cluster),
      function (d) {
        return d.id;
      }
    );

    // remove svg elements linked to deleted data
    this.nodeCircle.exit().remove();

    // create a new circle for each new node added to the data
    this.nodeCircle = this.nodeCircle
      .enter()
      .append('circle')
      .attr('r', (d) => nodeCircleSize(d, this))
      .attr('stroke', this.nodeStrokeColor)
      .attr('stroke-opacity', 0.8)
      .attr('stroke-width', this.strokeWidth)
      .attr('fill', (d) => nodeCircleColor(d, this))
      .style('visibility', (d) => {
        const result = d.display ? 'visible' : 'hidden';
        return result;
      })
      .call(
        d3
          .drag()
          .on('start', (e, d) => this.dragstarted(e, d, this))
          .on('drag', this.dragged)
          .on('end', (e, d) => this.dragended(e, d, this))
      )
      .on('click', (event, datum) => {
        this.dispatchEvent({
          type: 'click',
          message: 'node click event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mouseover', (event, datum) => {
        this.tooltip
          .style('visibility', 'visible')
          .style('color', 'black')
          .html(
            htmlTooltip(datum, [
              'color_id',
              'cluster',
              'parent',
              'child',
              'realNode',
              'display',
              'index',
              'group',
              'x',
              'y',
              'vx',
              'vy',
              'fx',
              'fy',
            ])
          );
        event.target.style['stroke'] = 'white';
        this.node_label
          .filter((e, j) => {
            return datum.index == j;
          })
          .style('fill', 'white')
          .style('opacity', '1');
        if (datum.child != undefined) {
          const allNodes = this.data.nodes.concat(this.data._nodes);
          for (const child_id of datum.child) {
            const child = allNodes.find((e) => e.id == child_id);
            if (child &amp;&amp; child.color_id != undefined)
              this.nodeCircle
                .filter((e) => e.id == child_id)
                .style('fill', modifyColorTint(child.color_id, 1.2));
          }
        }
        this.dispatchEvent({
          type: 'mouseover',
          message: 'node mouseover event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mouseout', (event, datum) => {
        this.tooltip.style('visibility', 'hidden');
        event.target.style['stroke'] = this.nodeStrokeColor;
        this.node_label
          .filter((e, j) => {
            return datum.index == j;
          })
          .style('fill', 'grey')
          .style('opacity', '0.5');
        if (datum.child != undefined) {
          const allNodes = this.data.nodes.concat(this.data._nodes);
          for (const child_id of datum.child) {
            const child = allNodes.find((e) => e.id == child_id);
            if (child &amp;&amp; child.color_id != undefined)
              this.nodeCircle
                .filter((e) => e.id == child_id)
                .style('fill', child.color_id);
          }
        }
        this.dispatchEvent({
          type: 'mouseout',
          message: 'node mouseout event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mousemove', (event, datum) => {
        this.tooltip
          .style('left', event.pageX + 30 + 'px')
          .style('top', event.pageY + 'px');
        this.dispatchEvent({
          type: 'mousemove',
          message: 'node mousemove event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .merge(this.nodeCircle);

    this.nodeCluster = this.nodeCluster.data(
      this.data.nodes.filter((d) => d.cluster),
      function (d) {
        return d.id;
      }
    );

    this.nodeCluster.exit().remove();

    // create a new rectangle for each new cluster added to the data
    this.nodeCluster = this.nodeCluster
      .enter()
      .append('rect')
      .attr('width', this.nodeSize * 2)
      .attr('height', this.nodeSize * 2)
      .attr('stroke-opacity', 0.8)
      .attr('stroke-width', this.strokeWidth)
      .attr('stroke', this.nodeStrokeColor)
      .attr('fill', this.defaultColor)
      .style('visibility', (d) => {
        const result = d.display ? 'visible' : 'hidden';
        return result;
      })
      .call(
        d3
          .drag()
          .on('start', (e, d) => this.dragstarted(e, d, this))
          .on('drag', this.dragged)
          .on('end', (e, d) => this.dragended(e, d, this))
      )
      .on('click', (event, datum) => {
        this.dispatchEvent({
          type: 'click',
          message: 'node click event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mouseover', (event, datum) => {
        this.tooltip
          .style('visibility', 'visible')
          .html(
            htmlTooltip(datum, [
              'color_id',
              'cluster',
              'realNode',
              'display',
              'index',
              'group',
              'x',
              'y',
              'vx',
              'vy',
              'fx',
              'fy',
            ])
          );
        event.target.style['stroke'] = 'white';
        this.node_label_cluster
          .filter((e, j) => {
            return datum.index == j;
          })
          .style('fill', 'white')
          .style('opacity', '1');
        this.dispatchEvent({
          type: 'mouseover',
          message: 'node mouseover event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mouseout', (event, datum) => {
        this.tooltip.style('visibility', 'hidden');
        event.target.style['stroke'] = this.nodeStrokeColor;
        this.node_label_cluster
          .filter((e, j) => {
            return datum.index == j;
          })
          .style('fill', 'grey')
          .style('opacity', '0.5');
        this.dispatchEvent({
          type: 'mouseout',
          message: 'node mouseout event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mousemove', (event, datum) => {
        this.tooltip
          .style('left', event.pageX + 30 + 'px')
          .style('top', event.pageY + 'px');
        this.dispatchEvent({
          type: 'mousemove',
          message: 'node mousemove event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .merge(this.nodeCluster);

    this.link = this.link.data(this.data.links, function (d) {
      return d.source.id + '-' + d.target.id;
    });

    this.link.exit().remove();

    // create a new line for each new link added to the data
    this.link = this.link
      .enter()
      .append('path')
      .attr('stroke-width', this.strokeWidth)
      .attr('stroke', this.linkColor)
      .attr('stroke-opacity', 0.8)
      .attr('marker-mid', 'url(#arrowhead)')
      .attr('stroke-dasharray', (d) => {
        let result;
        if (d.realLink) result = undefined;
        else result = '1';
        return result;
      })
      .attr('fill', 'none')
      .style('visibility', (d) => {
        let source;
        let target;
        const allNodes = this.data.nodes.concat(this.data._nodes);
        if (d.source.id == undefined) {
          source = this.data.nodes.find((element) => {
            return element.id == d.source;
          });
          target = allNodes.find((element) => {
            return element.id == d.target;
          });
        } else {
          source = d.source;
          target = d.target;
        }
        const result = source.display &amp;&amp; target.display ? 'visible' : 'hidden';
        return result;
      })
      .on('mouseover', (event, datum) => {
        this.tooltip
          .style('visibility', 'visible')
          .html(htmlTooltip(datum, ['index', 'realLink']));
        this.dispatchEvent({
          type: 'mouseover',
          message: 'node mouseover event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mouseout', (event, datum) => {
        this.tooltip.style('visibility', 'hidden');
        this.dispatchEvent({
          type: 'mouseout',
          message: 'node mouseout event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .on('mousemove', (event, datum) => {
        this.tooltip
          .style('left', event.pageX + 30 + 'px')
          .style('top', event.pageY + 'px');
        this.dispatchEvent({
          type: 'mousemove',
          message: 'node mousemove event',
          event: event,
          datum: datum,
          graphId: this.id,
        });
      })
      .merge(this.link);

    this.node_label = this.node_label.data(
      this.data.nodes.filter((d) => !d.cluster),
      function (d) {
        return d.id;
      }
    );
    this.node_label.exit().remove();
    this.node_label = this.node_label
      .enter()
      .append('text')
      .text(function (d) {
        return getUriLocalname(d.id);
      })
      .style('text-anchor', 'middle')
      .style('font-family', this.fontFamily)
      .style('font-size', this.fontSize)
      .style('text-shadow', '1px 1px black')
      .style('fill', 'white')
      .style('opacity', '0.3')
      .style('pointer-events', 'none')
      .style('visibility', (d) => {
        const res = d.display ? 'visible' : 'hidden';
        return res;
      })
      .attr('class', 'node_label')
      .merge(this.node_label);

    this.node_label_cluster = this.node_label_cluster.data(
      this.data.nodes.filter((d) => d.cluster),
      function (d) {
        return d.id;
      }
    );
    this.node_label_cluster.exit().remove();
    this.node_label_cluster = this.node_label_cluster
      .enter()
      .append('text')
      .text((d) => this.generateClusterLabel(d, this))
      .style('text-anchor', 'middle')
      .style('font-family', this.fontFamily)
      .style('font-size', this.fontSize)
      .style('text-shadow', '1px 1px black')
      .style('fill', 'white')
      .style('opacity', '0.3')
      .style('pointer-events', 'none')
      .style('visibility', (d) => {
        const res = d.display ? 'visible' : 'hidden';
        return res;
      })
      .attr('class', 'node_label')
      .merge(this.node_label_cluster);

    this.link_label = this.link_label.data(this.data.links, function (d) {
      return d.source.id + '-' + d.target.id;
    });

    this.link_label.exit().remove();

    this.link_label = this.link_label
      .enter()
      .append('text')
      .text(function (d) {
        return getUriLocalname(d.label);
      })
      .style('text-anchor', 'middle')
      .style('font-family', this.fontFamily)
      .style('font-size', this.fontSize)
      .style('text-shadow', '1px 1px black')
      .style('fill', 'white')
      .style('opacity', '1')
      .style('visibility', 'hidden')
      .style('pointer-events', 'none')
      .attr('class', 'link_label')
      .merge(this.link_label);

    // update and restart the simulation.
    this.simulation.nodes(this.data.nodes);
    this.simulation.force('link').links(this.data.links);
    this.simulation.alpha(1).restart();
    this.dispatchEvent({
      type: 'graph_updated',
      message: 'd3Graph update finished',
      event: null,
      graphId: this.id,
    });
  }

  /**
   * Getter for retrieving the d3 svg.
   *
   * @returns {d3.svg.node} return the D3 svg object that represents the graph's "canvas"
   */
  get canvas() {
    return this.svg.node();
  }

  /**
   * Getter for retrieving the d3 tooltip div.
   *
   * @returns {d3.div.node} return the D3 tooltip div
   */
  get tooltipDiv() {
    return this.tooltip.node();
  }

  /**
   * Hide the graph SVG
   */
  hide() {
    this.svg.style('display', 'hidden');
  }

  /**
   * Show the graph SVG
   */
  show() {
    this.svg.style('display', 'visible');
  }

  /**
   * Remove nodes and lines from the SVG.
   */
  clearCanvas() {
    this.svg.selectAll('g').remove();
    this.svg.selectAll('text').remove();
  }

  // / Interface Functions ///

  ticked(graph) {
    graph.nodeCluster
      .attr('x', (d) => d.x - graph.nodeSize)
      .attr('y', (d) => d.y - graph.nodeSize);

    graph.nodeCircle
      .attr('cx', function (d) {
        return d.x;
      })
      .attr('cy', function (d) {
        return d.y;
      });

    graph.link.attr('d', function (d) {
      /**
       * Calculate the vector normal to vector AB
       *
       * @param {object} A a point
       * @param {object} B a point
       * @returns {object} the normal vector
       */
      const getNormalVec = (A, B) => {
        let n;
        if (B.y - A.y != 0)
          n = {
            x: 1,
            y: (A.x - B.x) / (B.y - A.y),
          };
        else
          n = {
            x: 0,
            y: 1,
          };
        const norm = Math.sqrt(n.x * n.x + n.y * n.y);
        n.x = n.x / norm;
        n.y = n.y / norm;
        return n;
      };
      const n = getNormalVec(d.source, d.target);
      if (n.y * (d.target.y - d.source.y) &lt; 0) {
        n.y = -1 * n.y;
        n.x = -1 * n.x;
      }
      const k = 5 * d.linkindex;
      const Q = {
        x: (d.source.x + d.target.x) / 2 + n.x * k,
        y: (d.source.y + d.target.y) / 2 + n.y * k,
        n: n,
      };
      const path = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'path'
      );
      path.setAttribute(
        'd',
        'M ' +
          d.source.x +
          ' ' +
          d.source.y +
          ' ' +
          'Q ' +
          Q.x +
          ' ' +
          Q.y +
          ' ' +
          d.target.x +
          ' ' +
          d.target.y
      );
      const M = path.getPointAtLength(path.getTotalLength() / 2);
      const n1 = getNormalVec(d.source, M);
      const n2 = getNormalVec(d.target, M);
      if (n1.x * Q.n.x + n1.y * Q.n.y &lt; 0) {
        n1.y = -1 * n1.y;
        n1.x = -1 * n1.x;
      }
      if (n2.x * Q.n.x + n2.y * Q.n.y &lt; 0) {
        n2.y = -1 * n2.y;
        n2.x = -1 * n2.x;
      }
      const k12 = d.linkindex;
      const Q1 = {
        x: (d.source.x + M.x) / 2 + n1.x * k12,
        y: (d.source.y + M.y) / 2 + n1.y * k12,
      };
      const Q2 = {
        x: (d.target.x + M.x) / 2 + n2.x * k12,
        y: (d.target.y + M.y) / 2 + n2.y * k12,
      };
      return (
        'M ' +
        d.source.x +
        ' ' +
        d.source.y +
        ' Q ' +
        Q1.x +
        ' ' +
        Q1.y +
        ' ' +
        M.x +
        ' ' +
        M.y +
        ' Q ' +
        Q2.x +
        ' ' +
        Q2.y +
        ' ' +
        d.target.x +
        ' ' +
        d.target.y
      );
    });

    graph.node_label
      .attr('x', function (d) {
        return d.x;
      })
      .attr('y', function (d) {
        return d.y - graph.nodeSize - 3;
      });

    graph.node_label_cluster
      .attr('x', function (d) {
        return d.x;
      })
      .attr('y', function (d) {
        return d.y - graph.nodeSize - 3;
      });

    graph.link_label
      .attr('x', function (d) {
        return (d.source.x + d.target.x) / 2;
      })
      .attr('y', function (d) {
        return (d.source.y + d.target.y) / 2;
      });
  }

  /**
   *
   * @param {d3.D3DragEvent} event the drag event containing information on which node is being clicked and dragged
   * @param {object} d the dragged node
   * @param {D3GraphCanvas} graph this
   */
  dragstarted(event, d, graph) {
    if (!event.active) graph.simulation.alphaTarget(0.3).restart();
    if (d.fixed == undefined) {
      if (d.fx == undefined) {
        d.fixed = false;
        d.fx = d.x;
        d.fy = d.y;
      } else d.fixed = true;
    }
  }

  /**
   *
   * @param {d3.D3DragEvent} event the drag event containing information on which node is being clicked and dragged
   * @param {object} d the dragged node
   */
  dragged(event, d) {
    if (!d.fixed) {
      d.fx = event.x;
      d.fy = event.y;
    }
  }

  /**
   *
   * @param {d3.D3DragEvent} event the drag event containing information on which node is being clicked and dragged
   * @param {object} d the dragged node
   * @param {D3GraphCanvas} graph this
   */
  dragended(event, d, graph) {
    if (!event.active) graph.simulation.alphaTarget(0);
    if (!d.fixed) {
      d.fx = null;
      d.fy = null;
    }
  }

  /**
   * Check if a list of URIs have namespaces in the known namespace list. If so, replace
   * the namespace of the URI with a prefix. The known namespace list is declared in a
   * configuration file.
   *
   * @param {Array&lt;string>} legendContent the list of uris representing the content of the legend0
   * @returns {Array&lt;string>} returns the legend content with prefixes
   */
  prefixLegend(legendContent) {
    const prefixedLegendContent = [];
    for (const uri in legendContent) {
      const tURI = tokenizeURI(legendContent[uri]);
      if (Object.keys(this.knownNamespaceLabels).includes(tURI.namespace)) {
        prefixedLegendContent.push(
          `${this.knownNamespaceLabels[tURI.namespace]}:${tURI.localname}`
        );
      } else {
        prefixedLegendContent.push(legendContent[uri]);
      }
    }
    return prefixedLegendContent;
  }
}
</code></pre></article></section><footer class="footer" id="PeOAagUepe"><div class="wrapper">Fork: <a href="https://github.com/VCityTeam/UD-Viz">https://github.com/VCityTeam/UD-Viz</a></div></footer></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">@ud-viz/widget_sparql</a><div class="mobile-nav-links"><div class="navbar-item"><a id="Github-mobile" href="https://github.com/VCityTeam/UD-Viz" target="_blank">Github</a></div><div class="navbar-item"><a id="Examples-mobile" href="https://ud-viz.vcityliris.data.alpha.grandlyon.com/" target="_blank">Examples</a></div><div class="navbar-item"><a id="udvizHome-mobile" href="../" target="">udviz</a></div><div class="navbar-item"><a id="udviz/extensions_3d_tiles_temporal-mobile" href="../extensions_3d_tiles_temporal" target="">udviz/extensions_3d_tiles_temporal</a></div><div class="navbar-item"><a id="udviz/frame3d-mobile" href="../frame3d" target="">udviz/frame3d</a></div><div class="navbar-item"><a id="udviz/game_browser-mobile" href="../game_browser" target="">udviz/game_browser</a></div><div class="navbar-item"><a id="udviz/game_browser_template-mobile" href="../game_browser_template" target="">udviz/game_browser_template</a></div><div class="navbar-item"><a id="udviz/game_editor-mobile" href="../game_editor" target="">udviz/game_editor</a></div><div class="navbar-item"><a id="udviz/game_node-mobile" href="../game_node" target="">udviz/game_node</a></div><div class="navbar-item"><a id="udviz/game_node_template-mobile" href="../game_node_template" target="">udviz/game_node_template</a></div><div class="navbar-item"><a id="udviz/game_shared-mobile" href="../game_shared" target="">udviz/game_shared</a></div><div class="navbar-item"><a id="udviz/game_shared_template-mobile" href="../game_shared_template" target="">udviz/game_shared_template</a></div><div class="navbar-item"><a id="udviz/show_room-mobile" href="../show_room" target="">udviz/show_room</a></div><div class="navbar-item"><a id="udviz/smdb-mobile" href="../smdb" target="">udviz/smdb</a></div><div class="navbar-item"><a id="udviz/utils_browser-mobile" href="../utils_browser" target="">udviz/utils_browser</a></div><div class="navbar-item"><a id="udviz/utils_node-mobile" href="../utils_node" target="">udviz/utils_node</a></div><div class="navbar-item"><a id="udviz/utils_shared-mobile" href="../utils_shared" target="">udviz/utils_shared</a></div><div class="navbar-item"><a id="udviz/visualizer-mobile" href="../visualizer" target="">udviz/visualizer</a></div><div class="navbar-item"><a id="udviz/widget_3d_tiles-mobile" href="../widget_3d_tiles" target="">udviz/widget_3d_tiles</a></div><div class="navbar-item"><a id="udviz/widget_base_map-mobile" href="../widget_base_map" target="">udviz/widget_base_map</a></div><div class="navbar-item"><a id="udviz/widget_bookmark-mobile" href="../widget_bookmark" target="">udviz/widget_bookmark</a></div><div class="navbar-item"><a id="udviz/widget_camera_positioner-mobile" href="../widget_camera_positioner" target="">udviz/widget_camera_positioner</a></div><div class="navbar-item"><a id="udviz/widget_extensions_3d_tiles_temporal-mobile" href="../widget_extensions_3d_tiles_temporal" target="">udviz/widget_extensions_3d_tiles_temporal</a></div><div class="navbar-item"><a id="udviz/widget_geocoding-mobile" href="../widget_geocoding" target="">udviz/widget_geocoding</a></div><div class="navbar-item"><a id="udviz/widget_guided_tour-mobile" href="../widget_guided_tour" target="">udviz/widget_guided_tour</a></div><div class="navbar-item"><a id="udviz/widget_layer_choice-mobile" href="../widget_layer_choice" target="">udviz/widget_layer_choice</a></div><div class="navbar-item"><a id="udviz/widget_legonizer-mobile" href="../widget_legonizer" target="">udviz/widget_legonizer</a></div><div class="navbar-item"><a id="udviz/widget_planar_controls-mobile" href="../widget_planar_controls" target="">udviz/widget_planar_controls</a></div><div class="navbar-item"><a id="udviz/widget_slide_show-mobile" href="../widget_slide_show" target="">udviz/widget_slide_show</a></div><div class="navbar-item"><a id="udviz/widget_sparql-mobile" href="../widget_sparql" target="">udviz/widget_sparql</a></div><div class="navbar-item"><a id="udviz/widget_versioning-mobile" href="../widget_versioning" target="">udviz/widget_versioning</a></div><div class="navbar-item"><a id="udviz/widget_workspace-mobile" href="../widget_workspace" target="">udviz/widget_workspace</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="D3GraphCanvas_D3GraphCanvas.html">D3GraphCanvas</a></div><div class="sidebar-section-children"><a href="Graph.html">Graph</a></div><div class="sidebar-section-children"><a href="SparqlEndpointResponseProvider.html">SparqlEndpointResponseProvider</a></div><div class="sidebar-section-children"><a href="SparqlQuery.html">SparqlQuery</a></div><div class="sidebar-section-children"><a href="SparqlQueryWindow.html">SparqlQueryWindow</a></div><div class="sidebar-section-children"><a href="Table.html">Table</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-tutorials"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-Changelog.html">Changelog</a></div><div class="sidebar-section-children"><a href="tutorial-Contributing.html">Contributing</a></div><div class="sidebar-section-children"><a href="tutorial-Contributors.html">Contributors</a></div><div class="sidebar-section-children"><a href="tutorial-Definitions.html">Definitions</a></div><div class="sidebar-section-children"><a href="tutorial-Developers.html">Developers</a></div><div class="sidebar-section-children"><a href="tutorial-ReleasePublish.html">ReleasePublish</a></div><div class="sidebar-section-children"><a href="tutorial-Reproducibility.html">Reproducibility</a></div><div class="sidebar-section-children"><a href="tutorial-architecture.html">architecture</a></div><div class="sidebar-section-children"><a href="tutorial-game.html">game</a></div><div class="sidebar-section-children"><a href="tutorial-how_to_import.html">how_to_import</a></div><div class="sidebar-section-children"><a href="tutorial-initial_camera_transform.html">initial_camera_transform</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-global"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#OptionsRenderJSON">OptionsRenderJSON</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>